# This file contains the implementation of the parsing of the demographics xlsx
# file. It performs some basic sanity checks on the data, and generated
# City objects (as defined in city.py)

import xlrd
import os
from world.city_data.city import City
from util import Distribution

# The path of the demographics file we wish to parse (relative to this file)
DATA_FILE_PATH = "yossi_parameters_b.xlsx"

# Meanings of columns in the xlsx file
TOWN_SYMBOL_COLUMN = 0
HEBREW_NAME_COLUMN = 1
ENGLISH_NAME_COLUMN = 2
REGION_COLUMN = 3
NAFA_COLUMN = 4
AGE_DISTRIBUTION_COLUMNS = list(range(5, 21))
HOUSEHOLD_SIZE_DISTRIBUTION_COLUMNS = list(range(21, 28))
PERCENTAGE_OF_HOUSEHOLDS_WITH_65_PLUS_COLUMN = 28
PERCENTAGE_OF_HOUSEHOLDS_WITH_17_MINUS_COLUMN = 29
HOUSEHOLD_AMOUNT_COLUMN = 30
KIDS_PER_HOUSEHOLD_DISTRIBUTION_COLUMNS = list(range(31, 36))
KIDS_PER_HOUSEHOLD_SEGMENTS = [(i, i) for i in range(1, 6)]
POPULATION_COLUMN = 36
WORKPLACE_NAFA_DISTRIBUTION_COLUMNS = list(range(37, 55))
PROPORTION_WORKING_IN_CITY_COLUMN = 55
OLD_POPULATION_COLUMN = 56
COMPLETE_DATA_COLUMNS = [57, 58]

# The segments underlying the given age distribution.
# The smart household generation does not use the last segment, but rather
# makes an exponentially decreasing distribution.
# The naive household generation uses it.
AGE_SEGMENTS = [(5 * i, 5 * i + 4) for i in range(15)] + [(75, 95)]
# Same for household sizes, and again the smart generation does not use
# the last segment.
HOUSEHOLD_SIZE_SEGMENTS = [(i, i) for i in range(0, 7)] + [(7, 8)]

# We throw out all cities in nafa 25 since we have no yomemut data for it
BAD_NAFAS = [25]


def city_from_csv_line(line, nafa_col_values):
    """
    Parses a row of the data file and returns either a City object
    if it succeeded or None if it wishes to skip this line.
    :param line: The values of a row of the xlsx file that we wish to parse
    :param nafa_col_values: The descriptoin labels of the different
    nafas in the yomemut data.
    :return: A City object generated by the data in the row.
    """
    for i in COMPLETE_DATA_COLUMNS:
        assert line[i] in ("", "X")
    for i in COMPLETE_DATA_COLUMNS:
        if line[i] == '':
            # Bad line
            return
    nafa = int(line[NAFA_COLUMN])
    if nafa in BAD_NAFAS:
        # Bad city (belongs in a bad nafa)
        return
    if 70 <= nafa < 80:
        nafa = 7  # We can't tell apart areas in the west bank, apparently...
    age_amounts = [int(line[t]) for t in AGE_DISTRIBUTION_COLUMNS]
    population = sum(age_amounts)
    assert abs(population - int(line[POPULATION_COLUMN])) < 100, "inconsistent data in city {}: {} {}".format(
        line[ENGLISH_NAME_COLUMN], population, int(line[POPULATION_COLUMN])
    )
    age_data = [(amount / population, seg[0], seg[1] + 1) for amount, seg in zip(age_amounts, AGE_SEGMENTS)]
    age_distribution = Distribution(AGE_SEGMENTS, [c[0] for c in age_data])

    household_size_data = [0.0] + [float(line[t]) / 100 for t in HOUSEHOLD_SIZE_DISTRIBUTION_COLUMNS]
    total_household_size_percentages = sum(household_size_data)
    assert abs(total_household_size_percentages - 1.00) < 0.02, "Inconsistent data: %s" % total_household_size_percentages
    household_size_data = [float(t) / total_household_size_percentages for t in household_size_data]
    household_size_distribution = Distribution(HOUSEHOLD_SIZE_SEGMENTS, household_size_data)
    if line[ENGLISH_NAME_COLUMN].lower() == 'bene beraq':
        # We have better information about Bene Beraq (which goes beyond the xlsx maximum household size,
        # so we edit it in here.
        household_size_data = [0.0, 0.145, 0.238, 0.139, 0.12, 0.1, 0.082, 0.05, 0.038, 0.03, 0.021, 0.014, 0.01, 0.007, 0.006]
        household_size_distribution = Distribution([(i, i) for i in range(len(household_size_data))], household_size_data)

    kids_per_household_data = [float(line[t]) / 100 for t in KIDS_PER_HOUSEHOLD_DISTRIBUTION_COLUMNS]
    total_kids_per_household_percentages = sum(kids_per_household_data)
    assert abs(total_kids_per_household_percentages - 1.00) < 0.02, "Incosistent data: %s" % total_kids_per_household_percentages
    kids_per_household_data = [float(t) / total_kids_per_household_percentages for t in kids_per_household_data]
    kids_per_household_distribution = Distribution(KIDS_PER_HOUSEHOLD_SEGMENTS, kids_per_household_data)

    old_population = float(line[OLD_POPULATION_COLUMN]) * 1000
    growth_factor = population / old_population
    num_households = int(float(line[HOUSEHOLD_AMOUNT_COLUMN]) * 1000 * growth_factor)

    workplace_nafa_distribution = {}
    for (nafa_id, nafa_col_ind) in zip(nafa_col_values, WORKPLACE_NAFA_DISTRIBUTION_COLUMNS):
        assert nafa_id not in workplace_nafa_distribution
        workplace_nafa_distribution[nafa_id] = float(line[nafa_col_ind]) / 100.

    return City(
        town_symbol=line[TOWN_SYMBOL_COLUMN],
        hebrew_name=line[HEBREW_NAME_COLUMN],
        english_name=line[ENGLISH_NAME_COLUMN],
        region=line[REGION_COLUMN],
        nafa=nafa,
        population=population,
        location=None,
        density=None,
        num_jobs=None,
        age_distribution=age_distribution,
        age_data=age_data,
        total_households=num_households,
        household_size_distribution=household_size_distribution,
        household_size_data=household_size_data,
        kids_per_household_distribution=kids_per_household_distribution,
        kids_per_household_data=kids_per_household_data,
        percentage_of_households_with_65_plus=float(line[PERCENTAGE_OF_HOUSEHOLDS_WITH_65_PLUS_COLUMN]) / 100,
        percentage_of_households_with_17_minus=float(line[PERCENTAGE_OF_HOUSEHOLDS_WITH_17_MINUS_COLUMN]) / 100,
        percentage_of_households_with_single_parent=0.11,  # Country-wide average
        percentage_of_children_with_single_parent_in_household=0.07,  # Made up number that makes sense
        proportion_working_in_city=float(line[PROPORTION_WORKING_IN_CITY_COLUMN]) / 100,
        workplace_nafa_distribution=workplace_nafa_distribution,
        workplace_city_distribution=None
    )

def get_city_list_from_dem_xls():
    """
    Parses the xlsx file (saved in the hardcoded DATA_FILE_PATH path),
    constructs and returns a list of the cities it describes.
    :return: A list of the City objects it generated,
    with workplace_city_distribution-s not yet initialized
    """
    full_path = os.path.join(os.path.dirname(__file__), DATA_FILE_PATH)
    sheet = xlrd.open_workbook(full_path, 'r').sheet_by_index(0)
    assert sheet.cell(0, TOWN_SYMBOL_COLUMN).value == 'ids', 'Wrong file! %0'
    assert sheet.cell(2, TOWN_SYMBOL_COLUMN).value == 'town symbol', 'Wrong file!'
    assert sheet.cell(2, HEBREW_NAME_COLUMN).value == 'hebrew name', 'Wrong file!'
    assert sheet.cell(2, ENGLISH_NAME_COLUMN).value == 'english name', 'Wrong file!'
    assert sheet.cell(2, REGION_COLUMN).value == 'mahoz', 'Wrong file!'
    assert sheet.cell(2, NAFA_COLUMN).value == 'nafa', 'Wrong file!'
    assert sheet.cell(2, OLD_POPULATION_COLUMN).value == 'tot_2008', 'Wrong file!'
    for i in range(1, len(HOUSEHOLD_SIZE_DISTRIBUTION_COLUMNS)):
        assert sheet.cell(2, HOUSEHOLD_SIZE_DISTRIBUTION_COLUMNS[i - 1]).value == 'percentage of %d-member households' % i
    nafa_col_values = []
    for col_ind in WORKPLACE_NAFA_DISTRIBUTION_COLUMNS:
        assert sheet.cell(2, col_ind).value.startswith("nafa_"), "Wrong file!"
        nafa_col_values.append(int(sheet.cell(2, col_ind).value[len("nafa_"):]))
    all_cities = []
    for i in range(3, sheet.nrows):
        line = [sheet.cell(i, j).value for j in range(sheet.ncols)]
        try:
            city = city_from_csv_line(line, nafa_col_values)
        except Exception:
            print(line, i)
            raise
        if city is not None:
            all_cities.append(city)
    return all_cities
